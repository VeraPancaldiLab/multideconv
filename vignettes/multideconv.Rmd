---
title: "multideconv"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{multideconv}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This tutorial demonstrates how to use the `multideconv` package and explains the main functions of the pipeline for deconvolving RNA-seq data.

```{r setup}
library(multideconv)
```

The basic function is to perform cell type deconvolution using six default methods (quanTIseq, DeconRNASeq, CibersortX, EpiDISH, DWLS, MOMF) and nine default signatures (see the `signatures/` folder). The function accepts either raw counts or TPM-normalized counts as input (with genes as SYMBOLs).

Note: If you plan to use CibersortX, you must provide your credentials (see README for details). The resulting deconvolution matrix is automatically saved in the `Results/` directory.

```{r}
bulk = multideconv::raw_counts
deconv = compute.deconvolution(raw.counts = bulk, methods = c("Quantiseq", "Epidish", "DeconRNASeq", "DWLS", "MOMF"), 
                               normalized = TRUE, return = TRUE, file_name = "Tutorial")
```

To exclude specific methods or signatures, use the methods or signatures_exclude arguments:

```{r}
deconv = compute.deconvolution(raw.counts, methods = c("Quantiseq", "DWLS"), normalized = TRUE,
                               signatures_exclude = c("BPRNACan", "BPRNACanProMet", "BPRNACan3DProMet"), return = TRUE, file_name = "Tutorial")
```

To speed up computation, `multideconv` supports parallelization. Set doParallel = TRUE and specify the number of workers based on your system's resources:

```{r}
deconv = compute.deconvolution(raw.counts, methods = c("Quantiseq", "CBSX", "Epidish", "DeconRNASeq", "DWLS", "MOMF"),
                               normalized = TRUE, return = TRUE, file_name = "Tutorial", doParallel = TRUE, workers = 3)
```

If single-cell data is available, we recommend generating metacells to reduce computation time and prevent session crashes. Deconvolution methods that rely on single-cell data can be computationally intensive, especially with large matrices. We suggest using a maximum of 20k cells; if your object exceeds this size, creating metacells is strongly advised. However, if your computational resources are sufficient to handle the full single-cell dataset, you may skip this step.

We adapted functions from the R package hdWGCNA (Morabito et al., 2023; Langfelder et al., 2008) for the construction of metacells using the KNN algorithm.

-   sc_object: Normalized gene expression matrix with genes as rows and cells as columns

-   labels_column: Vector of cell annotations

-   samples_column: Vector of sample IDs for each cell

-   exclude_cells: Vector specifying which cell types to ignore during metacell construction (default is NULL)

-   min_cells: Minimum number of cells required to construct metacells in a group

-   k: Number of nearest neighbors used for the KNN algorithm

-   max_shared: Maximum number of cells shared between two metacells

-   n_workers: Number of cores to use for parallelizing metacell construction

-   min_meta: Minimum number of metacells required for a cell type to be retained

```{r}
metacells = create_metacells(sc_object, labels_column = cell_labels, samples_column = sample_labels, exclude_cells = NULL,
                             min_cells = 50, k = 15, max_shared = 15, n_workers = 4, min_meta = 10)
```

Once the single-cell data is prepared, users can supplement the default deconvolution methods with second-generation approaches such as AutogeneS, BayesPrism, Bisque, CPM, MuSic, and SCDC. These methods learn cell-type signatures directly from annotated single-cell RNA-seq data, rather than relying on predefined static signatures (Dietrich et al., 2024), to deconvolve bulk RNA-seq profiles.

-   sc_deconv: Boolean indicating whether to run second-generation methods

-   sc_matrix: Normalized single-cell gene expression matrix

-   sc_metadata: Dataframe containing single-cell metadata

-   cell_annotations: Vector of cell type labels

-   cell_samples: Vector of sample IDs

-   name_sc_signature: Name to assign to the resulting signature

```{r}
deconv = compute.deconvolution(raw.counts, normalized = TRUE, return = TRUE, file_name = "Tutorial", sc_deconv = TRUE, sc_matrix = sc.object, 
                               sc_metadata = sc.metadata, cell_annotations = cell_labels, cell_samples = bath_ids, name_sc_signature = "Test")
```

To run only the second-generation deconvolution methods based on single-cell data, without using any static cell-type signatures, use the following:

```{r}
deconv_sc = compute_sc_deconvolution_methods(raw_counts, normalized = FALSE, sc_object = metacells@assays$RNA@counts, sc_metadata = metacells@meta.data, 
                                             cell_annotations = "annotated_ct", samples_ids = "sample", name_object = "Test", 
                                             n_cores = 6, return = TRUE, file_name = "Tutorial")
```

To create cell type signatures, `multideconv` uses four methods: CibersortX, DWLS, MOMF, and BSeq-SC. You must provide single-cell data as input. Signatures are saved in the `custom_signatures/` directory, and returned as a list. To run BSeq-SC, supply the cell_markers argument, which should contain the differential markers for each cell type (these can be obtained using FindMarkers() or FindAllMarkers() from Seurat).

```{r}
signatures = create_sc_signatures(sc_obj, sc_metadata, cells_labels, sample_labels, bulk_rna = bulk, cell_markers = markers, name_signature = "Test")
```

To validate the generated signatures, we provide a benchmarking function to compare deconvolution outputs against known cell proportions (e.g., from single-cell or imaging data). The cells_extra argument should include any non-standard cell types present in your ground truth. Make sure cell names match those in the deconvolution matrix (e.g., use B.cells instead of B cells if that is the naming convention used - see README for more information).

```{r}
benchmark = compute.benchmark(deconv, groundtruth = cells_groundtruth, cells_extra = c("Mural.cells"), corr_type = "spearman",
                              scatter = FALSE, plot = TRUE, pval = 0.05, file_name = "Tutorial", with = 16, height = 8)
```

Deconvolution analysis reduces the dimensionality and heterogeneity of the deconvolution results. It uses the cell type processing algorithm described in the paper. It returns the cell type subgroups composition and the reduced deconvolution matrix, saved in the `Results/` directory.

-   deconvolution: Matrix of raw deconvolution results (output of compute.deconvolution())

-   corr: Minimum correlation threshold to group features

-   seed: Random seed for reproducibility

-   return: Whether to return results and save output files to the `Results/` directory

```{r}
deconv_subgroups = compute.deconvolution.analysis(deconvolution = deconv, corr = 0.7, seed = 123, file_name = "Tutorial", return = TRUE) 
```

If your deconvolution matrix contains non-standard cell types (see README), specify them using cells_extra to ensure proper subgrouping:

```{r}
deconv_subgroups = compute.deconvolution.analysis(deconvolution = deconv, corr = 0.7, seed = 123, return = TRUE,
                                                  cells_extra = c("Mural.cells", "Fibroblasts"), file_name = "Tutorial") 
```

Note: multideconv is built on top of existing frameworks and makes extensive use of the R packages immunedeconv and omnideconv. If you use multideconv in your work, please cite our package along with these foundational packages. We also encourage you to cite the individual deconvolution algorithms you employ in your analysis.

References

Sturm, G., Finotello, F., Petitprez, F., Zhang, J. D., Baumbach, J., Fridman, W. H., ..., List, M., Aneichyk, T. (2019). Comprehensive evaluation of transcriptome-based cell-type quantification methods for immuno-oncology. Bioinformatics, 35(14), i436-i445. https://doi.org/10.1093/bioinformatics/btz363

Benchmarking second-generation methods for cell-type deconvolution of transcriptomic data. Dietrich, Alexander and Merotto, Lorenzo and Pelz, Konstantin and Eder, Bernhard and Zackl, Constantin and Reinisch, Katharina and Edenhofer, Frank and Marini, Federico and Sturm, Gregor and List, Markus and Finotello, Francesca. (2024) https://doi.org/10.1101/2024.06.10.598226

Langfelder, P., Horvath, S. WGCNA: an R package for weighted correlation network analysis. BMC Bioinformatics 9, 559 (2008). https://doi.org/10.1186/1471-2105-9-559

Morabito, S., Reese, F., Rahimzadeh, N., Miyoshi, E., & Swarup, V. (2023). hdWGCNA identifies co-expression networks in high-dimensional transcriptomics data. Cell Reports Methods, 3(6), 100498. https://doi.org/10.1016/j.crmeth.2023.100498
